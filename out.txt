Linker Visiting: ~lib/json-as/index
Linker Visiting: ~lib/json-as/assembly/index
Added Function: deserializeArray in ~lib/json-as/assembly/deserialize/simple/array
Added Function: deserializeStruct in ~lib/json-as/assembly/deserialize/simple/struct
Added Function: deserializeMap in ~lib/json-as/assembly/deserialize/simple/map
Added Function: deserializeArbitrary in ~lib/json-as/assembly/deserialize/simple/arbitrary
Added Function: deserializeObject in ~lib/json-as/assembly/deserialize/simple/object
Added Function: stringify in ~lib/json-as/assembly/index
Added Function: parse in ~lib/json-as/assembly/index
Added Function: __serialize in ~lib/json-as/assembly/index
Added Function: __deserialize in ~lib/json-as/assembly/index
Linker Visiting: ~lib/json-as/lib/as-bs
Linker Visiting: ~lib/json-as/assembly/serialize/simple/string
Linker Visiting: ~lib/json-as/assembly/serialize/simple/array
Linker Visiting: ~lib/json-as/assembly/serialize/simple/map
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/bool
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/float
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/struct
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/map
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/date
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/integer
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/string
Linker Visiting: ~lib/json-as/assembly/serialize/simple/arbitrary
Linker Visiting: ~lib/json-as/assembly/custom/sink
Linker Visiting: ~lib/json-as/assembly/custom/chars
Linker Visiting: ~lib/json-as/assembly/serialize/simple/bool
Linker Visiting: ~lib/json-as/assembly/serialize/simple/integer
Linker Visiting: ~lib/json-as/assembly/serialize/simple/float
Linker Visiting: ~lib/json-as/assembly/serialize/simple/struct
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/arbitrary
Linker Visiting: ~lib/json-as/assembly/serialize/simple/object
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/object
Linker Visiting: ~lib/json-as/assembly/serialize/simple/raw
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/raw
Linker Visiting: ~lib/json-as/assembly/custom/util
Linker Visiting: ~lib/json-as/assembly/globals/tables
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array/arbitrary
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array/array
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array/bool
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array/float
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array/integer
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array/map
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array/struct
Added Function: deserializeStructArray in ~lib/json-as/assembly/deserialize/simple/array/struct
Linker Visiting: ~lib/json-as/assembly/deserialize/simple/array/string
Linker Visiting: assembly/test
Added Function: foo in assembly/foo
Linker Visiting: assembly/types/error
Linker Visiting: assembly/foo
Linker Visiting: assembly/types/exception
Linker Visiting: assembly/types/abort
Found try: try {
  JSON.parse<Vec3>("lol");
  console.log("This should not execute");
} catch (e) {
  console.log("Got an error: " + e.toString());
  try {
    foo();
  } catch (e) {
    console.log("Got another error: " + e.toString());
  }
} finally {
  console.log("Gracefully shutting down...");
  process.exit(0);
}
~lib/json-as/assembly/index 6
Import: import {
  __ExceptionState
} from "./types/exception" in assembly/test.ts
~lib/json-as/assembly/index 6
assembly/types/error 0
assembly/foo 1
Set Fn __try_parse
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
Import: import {
  __ErrorState
} from "../../../assembly/types/error" in ~lib/json-as/assembly/index.ts
Fn (Throw): @inline
export function __try_parse<T>(data: string): T {
  const dataSize = bytes(data);
  const dataPtr = changetype<usize>(data);
  if (isBoolean<T>()) {
    return deserializeBoolean(dataPtr, dataPtr + dataSize) as T;
  } else if (isInteger<T>()) {
    return deserializeInteger<T>(dataPtr, dataPtr + dataSize);
  } else if (isFloat<T>()) {
    return deserializeFloat<T>(dataPtr, dataPtr + dataSize);
  } else if (isNullable<T>() && dataSize == 8 && load<u64>(dataPtr) == 30399761348886638) {
    return null;
  } else if (isString<T>()) {
    return deserializeString(dataPtr, dataPtr + dataSize, __new(dataSize - 4, idof<string>()));
  } else if (isArray<T>()) {
    return inline.always(deserializeArray<nonnull<T>>(dataPtr, dataPtr + dataSize, changetype<usize>(instantiate<T>())));
  } else {
    let type: nonnull<T> = changetype<nonnull<T>>(0);
    if (isDefined(type.__DESERIALIZE_CUSTOM)) {
      const out = changetype<nonnull<T>>(0);
      if (isDefined(type.__INITIALIZE)) out.__INITIALIZE();
;
      return out.__DESERIALIZE_CUSTOM(ptrToStr(dataPtr, dataPtr + dataSize));
    } else if (isDefined(type.__DESERIALIZE)) {
      const out = __new(offsetof<nonnull<T>>(), idof<nonnull<T>>());
      if (isDefined(type.__INITIALIZE)) changetype<nonnull<T>>(out).__INITIALIZE();
;
      return inline.always(deserializeStruct<nonnull<T>>(dataPtr, dataPtr + dataSize, out));
    } else if (type instanceof Map) {
      return inline.always(deserializeMap<nonnull<T>>(dataPtr, dataPtr + dataSize, 0));
    } else if (type instanceof Date) {
      return deserializeDate(dataPtr, dataPtr + dataSize);
    } else if (type instanceof JSON.Raw) {
      return deserializeRaw(dataPtr, dataPtr + dataSize);
    } else if (type instanceof JSON.Value) {
      return inline.always(deserializeArbitrary(dataPtr, dataPtr + dataSize, 0));
    } else if (type instanceof JSON.Obj) {
      return inline.always(deserializeObject(dataPtr, dataPtr + dataSize, 0));
    } else if (type instanceof JSON.Box) {
      return new JSON.Box(parseBox(data, changetype<nonnull<T>>(0).value));
    } else {
      throw new Error(`Could not deserialize data ${data} to type ${nameof<T>()}. Make sure to add the correct decorators to classes.`);
    }
  }
}
Return Type: T derived from __try_parse
Return: if (isBoolean<T>()) return false;
else if (isInteger<T>()) return 0;
else if (isFloat<T>()) 0;
else if (isManaged<T>() || isUnmanaged<T>()) return changetype<T>(0);
else return
Breaker (Throw): if (isBoolean<T>()) return false;
else if (isInteger<T>()) return 0;
else if (isFloat<T>()) 0;
else if (isManaged<T>() || isUnmanaged<T>()) return changetype<T>(0);
else return
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
~lib/json-as/lib/as-bs 0
~lib/json-as/assembly/serialize/simple/string 0
~lib/json-as/assembly/serialize/simple/array 0
~lib/json-as/assembly/serialize/simple/map 0
~lib/json-as/assembly/deserialize/simple/bool 0
~lib/json-as/assembly/deserialize/simple/array 1
~lib/json-as/assembly/deserialize/simple/float 0
~lib/json-as/assembly/deserialize/simple/struct 1
~lib/json-as/assembly/deserialize/simple/map 1
~lib/json-as/assembly/deserialize/simple/date 0
~lib/json-as/assembly/deserialize/simple/integer 0
~lib/json-as/assembly/deserialize/simple/string 0
~lib/json-as/assembly/serialize/simple/arbitrary 0
~lib/json-as/assembly/custom/sink 0
~lib/json-as/assembly/custom/chars 0
~lib/json-as/assembly/serialize/simple/bool 0
~lib/json-as/assembly/serialize/simple/integer 0
~lib/json-as/assembly/serialize/simple/float 0
~lib/json-as/assembly/serialize/simple/struct 0
~lib/json-as/assembly/deserialize/simple/arbitrary 1
~lib/json-as/assembly/serialize/simple/object 0
~lib/json-as/assembly/deserialize/simple/object 1
~lib/json-as/assembly/serialize/simple/raw 0
~lib/json-as/assembly/deserialize/simple/raw 0
Release Fn __try_parse
import {
  __ErrorState
} from "../../../assembly/types/error";
import {
  bs
} from "../lib/as-bs";
import {
  serializeString
} from "./serialize/simple/string";
import {
  serializeArray
} from "./serialize/simple/array";
import {
  serializeMap
} from "./serialize/simple/map";
import {
  deserializeBoolean
} from "./deserialize/simple/bool";
import {
  deserializeArray
} from "./deserialize/simple/array";
import {
  deserializeFloat
} from "./deserialize/simple/float";
import {
  deserializeStruct
} from "./deserialize/simple/struct";
import {
  deserializeMap
} from "./deserialize/simple/map";
import {
  deserializeDate
} from "./deserialize/simple/date";
import {
  deserializeInteger
} from "./deserialize/simple/integer";
import {
  deserializeString
} from "./deserialize/simple/string";
import {
  serializeArbitrary
} from "./serialize/simple/arbitrary";
import {
  Sink
} from "./custom/sink";
import {
  NULL_WORD,
  QUOTE
} from "./custom/chars";
import {
  dtoa_buffered,
  itoa_buffered
} from "util/number";
import {
  serializeBool
} from "./serialize/simple/bool";
import {
  serializeInteger
} from "./serialize/simple/integer";
import {
  serializeFloat
} from "./serialize/simple/float";
import {
  serializeStruct
} from "./serialize/simple/struct";
import {
  ptrToStr
} from "./util/ptrToStr";
import {
  atoi,
  bytes
} from "./util";
import {
  deserializeArbitrary
} from "./deserialize/simple/arbitrary";
import {
  serializeObject
} from "./serialize/simple/object";
import {
  deserializeObject
} from "./deserialize/simple/object";
import {
  serializeRaw
} from "./serialize/simple/raw";
import {
  deserializeRaw
} from "./deserialize/simple/raw";
@inline
const STORAGE = offsetof<JSON.Value>("storage");
export namespace JSON {
  export namespace Memory {
    export function shrink(): void {
      bs.resize(64);
    }
  }
  @inline
  export function stringify<T>(data: T, out: string | null = null): string {
    if (isBoolean<T>()) {
      if (out) {
        if (<bool>data == true) {
          out = changetype<string>(__renew(changetype<usize>(out), 8));
          store<u64>(changetype<usize>(out), 28429475166421108);
        } else {
          out = changetype<string>(__renew(changetype<usize>(out), 10));
          store<u64>(changetype<usize>(out), 32370086184550502);
          store<u16>(changetype<usize>(out), 101, 8);
        }
        return out;
      }
      return data ? "true" : "false";
    } else if (isInteger<T>() && !isSigned<T>() && nameof<T>() == "usize" && data == 0) {
      if (out) {
        out = changetype<string>(__renew(changetype<usize>(out), 8));
        store<u64>(changetype<usize>(out), 30399761348886638);
        return out;
      }
      return NULL_WORD;
    } else if (isInteger<T>(data)) {
      if (out) {
        out = changetype<string>(__renew(changetype<usize>(out), sizeof<T>() << 3));
        const bytes = itoa_buffered(changetype<usize>(out), data) << 1;
        return (out = changetype<string>(__renew(changetype<usize>(out), bytes)));
      }
      return data.toString();
    } else if (isFloat<T>(data)) {
      if (out) {
        out = changetype<string>(__renew(changetype<usize>(out), 64));
        const bytes = dtoa_buffered(changetype<usize>(out), data) << 1;
        return (out = changetype<string>(__renew(changetype<usize>(out), bytes)));
      }
      return data.toString();
    } else if (isNullable<T>() && changetype<usize>(data) == <usize>0) {
      if (out) {
        out = changetype<string>(__renew(changetype<usize>(out), 8));
        store<u64>(changetype<usize>(out), 30399761348886638);
        return out;
      }
      return NULL_WORD;
    } else if (isString<nonnull<T>>()) {
      serializeString(changetype<string>(data));
      return bs.out<string>();
    } else if (isDefined(data.__SERIALIZE_CUSTOM)) {
      inline.always(data.__SERIALIZE_CUSTOM(changetype<usize>(data)));
      return bs.out<string>();
    } else if (isDefined(data.__SERIALIZE)) {
      inline.always(data.__SERIALIZE(changetype<usize>(data)));
      return bs.out<string>();
    } else if (data instanceof Date) {
      out = out ? changetype<string>(__renew(changetype<usize>(out), 52)) : changetype<string>(__new(52, idof<string>()));
      store<u16>(changetype<usize>(out), QUOTE);
      memory.copy(changetype<usize>(out) + 2, changetype<usize>(data.toISOString()), 48);
      store<u16>(changetype<usize>(out), QUOTE, 50);
      return changetype<string>(out);
    } else if (data instanceof Array) {
      inline.always(serializeArray(changetype<nonnull<T>>(data)));
      return bs.out<string>();
    } else if (data instanceof Map) {
      inline.always(serializeMap(changetype<nonnull<T>>(data)));
      return bs.out<string>();
    } else if (data instanceof JSON.Raw) {
      inline.always(serializeRaw(data));
      return bs.out<string>();
    } else if (data instanceof JSON.Value) {
      inline.always(serializeArbitrary(data));
      return bs.out<string>();
    } else if (data instanceof JSON.Obj) {
      inline.always(serializeObject(data));
      return bs.out<string>();
    } else if (data instanceof JSON.Box) {
      return JSON.stringify(data.value);
    } else {
      throw new Error(`Could not serialize data of type ${nameof<T>()}. Make sure to add the correct decorators to classes.`);
    }
  }
  @inline
  export function parse<T>(data: string): T {
    const dataSize = bytes(data);
    const dataPtr = changetype<usize>(data);
    if (isBoolean<T>()) {
      return deserializeBoolean(dataPtr, dataPtr + dataSize) as T;
    } else if (isInteger<T>()) {
      return deserializeInteger<T>(dataPtr, dataPtr + dataSize);
    } else if (isFloat<T>()) {
      return deserializeFloat<T>(dataPtr, dataPtr + dataSize);
    } else if (isNullable<T>() && dataSize == 8 && load<u64>(dataPtr) == 30399761348886638) {
      return null;
    } else if (isString<T>()) {
      return deserializeString(dataPtr, dataPtr + dataSize, __new(dataSize - 4, idof<string>()));
    } else if (isArray<T>()) {
      return inline.always(deserializeArray<nonnull<T>>(dataPtr, dataPtr + dataSize, changetype<usize>(instantiate<T>())));
    } else {
      let type: nonnull<T> = changetype<nonnull<T>>(0);
      if (isDefined(type.__DESERIALIZE_CUSTOM)) {
        const out = changetype<nonnull<T>>(0);
        if (isDefined(type.__INITIALIZE)) out.__INITIALIZE();
;
        return out.__DESERIALIZE_CUSTOM(ptrToStr(dataPtr, dataPtr + dataSize));
      } else if (isDefined(type.__DESERIALIZE)) {
        const out = __new(offsetof<nonnull<T>>(), idof<nonnull<T>>());
        if (isDefined(type.__INITIALIZE)) changetype<nonnull<T>>(out).__INITIALIZE();
;
        return inline.always(deserializeStruct<nonnull<T>>(dataPtr, dataPtr + dataSize, out));
      } else if (type instanceof Map) {
        return inline.always(deserializeMap<nonnull<T>>(dataPtr, dataPtr + dataSize, 0));
      } else if (type instanceof Date) {
        return deserializeDate(dataPtr, dataPtr + dataSize);
      } else if (type instanceof JSON.Raw) {
        return deserializeRaw(dataPtr, dataPtr + dataSize);
      } else if (type instanceof JSON.Value) {
        return inline.always(deserializeArbitrary(dataPtr, dataPtr + dataSize, 0));
      } else if (type instanceof JSON.Obj) {
        return inline.always(deserializeObject(dataPtr, dataPtr + dataSize, 0));
      } else if (type instanceof JSON.Box) {
        return new JSON.Box(parseBox(data, changetype<nonnull<T>>(0).value));
      } else {
        throw new Error(`Could not deserialize data ${data} to type ${nameof<T>()}. Make sure to add the correct decorators to classes.`);
      }
    }
  }
  @inline
  export function __try_parse<T>(data: string): T {
    const dataSize = bytes(data);
    const dataPtr = changetype<usize>(data);
    if (isBoolean<T>()) {
      return deserializeBoolean(dataPtr, dataPtr + dataSize) as T;
    } else if (isInteger<T>()) {
      return deserializeInteger<T>(dataPtr, dataPtr + dataSize);
    } else if (isFloat<T>()) {
      return deserializeFloat<T>(dataPtr, dataPtr + dataSize);
    } else if (isNullable<T>() && dataSize == 8 && load<u64>(dataPtr) == 30399761348886638) {
      return null;
    } else if (isString<T>()) {
      return deserializeString(dataPtr, dataPtr + dataSize, __new(dataSize - 4, idof<string>()));
    } else if (isArray<T>()) {
      return inline.always(deserializeArray<nonnull<T>>(dataPtr, dataPtr + dataSize, changetype<usize>(instantiate<T>())));
    } else {
      let type: nonnull<T> = changetype<nonnull<T>>(0);
      if (isDefined(type.__DESERIALIZE_CUSTOM)) {
        const out = changetype<nonnull<T>>(0);
        if (isDefined(type.__INITIALIZE)) out.__INITIALIZE();
;
        return out.__DESERIALIZE_CUSTOM(ptrToStr(dataPtr, dataPtr + dataSize));
      } else if (isDefined(type.__DESERIALIZE)) {
        const out = __new(offsetof<nonnull<T>>(), idof<nonnull<T>>());
        if (isDefined(type.__INITIALIZE)) changetype<nonnull<T>>(out).__INITIALIZE();
;
        return inline.always(deserializeStruct<nonnull<T>>(dataPtr, dataPtr + dataSize, out));
      } else if (type instanceof Map) {
        return inline.always(deserializeMap<nonnull<T>>(dataPtr, dataPtr + dataSize, 0));
      } else if (type instanceof Date) {
        return deserializeDate(dataPtr, dataPtr + dataSize);
      } else if (type instanceof JSON.Raw) {
        return deserializeRaw(dataPtr, dataPtr + dataSize);
      } else if (type instanceof JSON.Value) {
        return inline.always(deserializeArbitrary(dataPtr, dataPtr + dataSize, 0));
      } else if (type instanceof JSON.Obj) {
        return inline.always(deserializeObject(dataPtr, dataPtr + dataSize, 0));
      } else if (type instanceof JSON.Box) {
        return new JSON.Box(parseBox(data, changetype<nonnull<T>>(0).value));
      } else {
        __ErrorState.error(`Could not deserialize data ${data} to type ${nameof<T>()}. Make sure to add the correct decorators to classes.`);
        if (isBoolean<T>()) return false;
else if (isInteger<T>()) return 0;
else if (isFloat<T>()) 0;
else if (isManaged<T>() || isUnmanaged<T>()) return changetype<T>(0);
else return;
      }
    }
  }
  export enum Types {
    Raw = 0,
    U8 = 1,
    U16 = 2,
    U32 = 3,
    U64 = 4,
    F32 = 5,
    F64 = 6,
    Null = 7,
    Bool = 8,
    String = 9,
    Object = 10,
    Array = 12,
    Struct = 13
  }
  export class Raw {
    public data: string;
    constructor(data: string) {
      .data = data;
    }
    set(data: string): void {
      .data = data;
    }
    toString(): string {
      return .data;
    }
    @inline
    static from(data: string): JSON.Raw {
      return new JSON.Raw(data);
    }
  }
  export class Value {
    static METHODS: Map<u32, u32> = new Map<u32, u32>();
    public type: i32;
    private storage: u64;
    private constructor() {
      unreachable();
    }
    @inline
    static empty(): JSON.Value {
      return changetype<JSON.Value>(__new(offsetof<JSON.Value>(), idof<JSON.Value>()));
    }
    @inline
    static from<T>(value: T): JSON.Value {
      if (value instanceof JSON.Value) {
        return value;
      }
      const out = changetype<JSON.Value>(__new(offsetof<JSON.Value>(), idof<JSON.Value>()));
      out.set<T>(value);
      return out;
    }
    @inline
    set<T>(value: T): void {
      if (isBoolean<T>()) {
        .type = JSON.Types.Bool;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (isInteger<T>() && !isSigned<T>() && changetype<usize>(value) == 0 && nameof<T>() == "usize") {
        .type = JSON.Types.Null;
        store<usize>(changetype<usize>(), 0, STORAGE);
      } else if (value instanceof u8 || value instanceof i8) {
        .type = JSON.Types.U8;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (value instanceof u16 || value instanceof i16) {
        .type = JSON.Types.U16;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (value instanceof u32 || value instanceof i32) {
        .type = JSON.Types.U32;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (value instanceof u64 || value instanceof i64) {
        .type = JSON.Types.U64;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (value instanceof f32) {
        .type = JSON.Types.F32;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (value instanceof f64) {
        .type = JSON.Types.F64;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (isString<T>()) {
        .type = JSON.Types.String;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (value instanceof JSON.Raw) {
        .type = JSON.Types.Raw;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (value instanceof Map) {
        if (idof<T>() !== idof<Map<string, JSON.Value>>()) {
          abort("Maps must be of type Map<string, JSON.Value>!");
        }
        .type = JSON.Types.Struct;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (isDefined(value.__SERIALIZE_CUSTOM)) {
        .type = idof<T>() + JSON.Types.Struct;
        if (!JSON.Value.METHODS.has(idof<T>())) JSON.Value.METHODS.set(idof<T>(), value.__SERIALIZE_CUSTOM.index);
;
        store<usize>(changetype<usize>(), changetype<usize>(value), STORAGE);
      } else if (isDefined(value.__SERIALIZE)) {
        .type = idof<T>() + JSON.Types.Struct;
        if (!JSON.Value.METHODS.has(idof<T>())) JSON.Value.METHODS.set(idof<T>(), value.__SERIALIZE.index);
;
        store<usize>(changetype<usize>(), changetype<usize>(value), STORAGE);
      } else if (value instanceof JSON.Obj) {
        .type = JSON.Types.Object;
        store<T>(changetype<usize>(), value, STORAGE);
      } else if (isArray<T>() && idof<valueof<T>>() == idof<JSON.Value>()) {
        .type = JSON.Types.Array;
        store<T>(changetype<usize>(), value, STORAGE);
      }
    }
    @inline
    get<T>(): T {
      return load<T>(changetype<usize>(), STORAGE);
    }
    toString(): string {
      switch (.type) {
        case JSON.Types.U8:
          return .get<u8>().toString();

        case JSON.Types.U16:
          return .get<u16>().toString();

        case JSON.Types.U32:
          return .get<u32>().toString();

        case JSON.Types.U64:
          return .get<u64>().toString();

        case JSON.Types.F32:
          return .get<f32>().toString();

        case JSON.Types.F64:
          return .get<f64>().toString();

        case JSON.Types.String:
          return "\"" + .get<string>() + "\"";

        case JSON.Types.Bool:
          return .get<boolean>() ? "true" : "false";

        case JSON.Types.Raw:
          {
            return .get<JSON.Raw>().toString();
          }

        case JSON.Types.Array:
          {
            const arr = .get<Array<JSON.Value>>();
            if (!arr.length) return "[]";
;
            const out = Sink.fromStringLiteral("[");
            const end = arr.length - 1;
            for (let i = 0; i < end; i++) {
              const element = unchecked(arr[i]);
              out.write(element.toString());
              out.write(",");
            }
            const element = unchecked(arr[end]);
            out.write(element.toString());
            out.write("]");
            return out.toString();
          }

        case JSON.Types.Object:
          {
            return JSON.stringify(.get<JSON.Obj>());
          }

        default:
          {
            const fn = JSON.Value.METHODS.get(.type - JSON.Types.Struct);
            const value = .get<usize>();
            call_indirect<void>(fn, 0, value);
            return bs.out<string>();
          }

}
    }
  }
  export class Obj {
    private stackSize: u32 = 6;
    private storage: Map<string, JSON.Value> = new Map<string, JSON.Value>();
    constructor() {}
    @inline
    get size(): i32 {
      return .storage.size;
    }
    @inline
    set<T>(key: string, value: T): void {
      if (!.storage.has(key)) .stackSize += bytes(key) + 8;
;
      .storage.set(key, JSON.Value.from<T>(value));
    }
    @inline
    get(key: string): JSON.Value | null {
      if (!.storage.has(key)) return null;
;
      return .storage.get(key);
    }
    @inline
    has(key: string): bool {
      return .storage.has(key);
    }
    @inline
    delete(key: string): bool {
      return .storage.delete(key);
    }
    @inline
    keys(): Array<string> {
      return .storage.keys();
    }
    @inline
    values(): Array<JSON.Value> {
      return .storage.values();
    }
    @inline
    toString(): string {
      return JSON.stringify();
    }
    @inline
    static from<T>(value: T): JSON.Obj {
      if (value instanceof JSON.Obj) return value;
;
      const out = changetype<JSON.Obj>(__new(offsetof<JSON.Obj>(), idof<JSON.Obj>()));
      if (value instanceof Map) {}
      return out;
    }
  }
  export class Box<T> {
    constructor(public value: T) {
      if (!isInteger<T>() && !isFloat<T>()) ERROR("JSON.Box should only hold primitive types!");
;
    }
    @inline
    set(value: T): Box<T> {
      .value = value;
      return ;
    }
    @inline
    static from<T>(value: T): Box<T> {
      return new Box(value);
    }
    toString(): string {
      if (isNullable<this>() && changetype<usize>() == null) return "null";
;
      if (isDefined(.value.toString)) return .value.toString();
;
      return "null";
    }
  }
  export function __serialize<T>(src: T): void {
    if (isBoolean<T>()) {
      serializeBool(src as bool);
    } else if (isInteger<T>() && nameof<T>() == "usize" && src == 0) {
      bs.proposeSize(8);
      store<u64>(bs.offset, 30399761348886638);
      bs.offset += 8;
    } else if (isInteger<T>()) {
      serializeInteger<T>(src);
    } else if (isFloat<T>(src)) {
      serializeFloat<T>(src);
    } else if (isNullable<T>() && changetype<usize>(src) == <usize>0) {
      bs.proposeSize(8);
      store<u64>(bs.offset, 30399761348886638);
      bs.offset += 8;
    } else if (isString<nonnull<T>>()) {
      serializeString(src as string);
    } else if (isDefined(src.__SERIALIZE_CUSTOM)) {
      return src.__SERIALIZE_CUSTOM(changetype<nonnull<T>>(src));
    } else if (isDefined(src.__SERIALIZE)) {
      inline.always(serializeStruct(changetype<nonnull<T>>(src)));
    } else if (src instanceof Date) {
      inline.always(serializeDate(changetype<nonnull<T>>(src)));
    } else if (src instanceof Array) {
      inline.always(serializeArray(changetype<nonnull<T>>(src)));
    } else if (src instanceof Map) {
      inline.always(serializeMap(changetype<nonnull<T>>(src)));
    } else if (src instanceof JSON.Raw) {
      serializeRaw(src);
    } else if (src instanceof JSON.Value) {
      inline.always(serializeArbitrary(src));
    } else if (src instanceof JSON.Obj) {
      inline.always(serializeObject(src));
    } else if (src instanceof JSON.Box) {
      __serialize(src.value);
    } else {
      throw new Error(`Could not serialize provided data. Make sure to add the correct decorators to classes.`);
    }
  }
  export function __deserialize<T>(srcStart: usize, srcEnd: usize, dst: usize = 0): T {
    if (isBoolean<T>()) {
      return deserializeBoolean(srcStart, srcEnd);
    } else if (isInteger<T>()) {
      return atoi<T>(srcStart, srcEnd);
    } else if (isFloat<T>()) {
      return deserializeFloat<T>(srcStart, srcEnd);
    } else if (isString<T>()) {
      return deserializeString(srcStart, srcEnd, dst);
    } else if (isArray<T>()) {
      return inline.always(deserializeArray<T>(srcStart, srcEnd, dst));
    } else if (isNullable<T>() && srcEnd - srcStart == 8 && load<u64>(srcStart) == 30399761348886638) {
      return null;
    } else {
      let type: nonnull<T> = changetype<nonnull<T>>(0);
      if (isDefined(type.__DESERIALIZE_CUSTOM)) {
        const out = __new(offsetof<nonnull<T>>(), idof<nonnull<T>>());
        if (isDefined(type.__INITIALIZE)) changetype<nonnull<T>>(out).__INITIALIZE();
;
        return changetype<nonnull<T>>(out).__DESERIALIZE_CUSTOM(ptrToStr(srcStart, srcEnd));
      } else if (isDefined(type.__DESERIALIZE)) {
        return inline.always(deserializeStruct<T>(srcStart, srcEnd, dst));
      } else if (type instanceof Map) {
        return inline.always(deserializeMap<T>(srcStart, srcEnd, dst));
      } else if (type instanceof Date) {
        return deserializeDate(srcStart, srcEnd);
      } else if (type instanceof JSON.Raw) {
        return deserializeRaw(srcStart, srcEnd);
      } else if (type instanceof JSON.Value) {
        return inline.always(deserializeArbitrary(srcStart, srcEnd, 0));
      } else if (type instanceof JSON.Box) {
        return new JSON.Box(deserializeBox(srcStart, srcEnd, dst, changetype<nonnull<T>>(0).value));
      }
    }
    throw new Error(`Could not deserialize data '${ptrToStr(srcStart, srcEnd).slice(0, 100)}' to type. Make sure to add the correct decorators to classes.`);
  }
}
@inline
function parseBox<T>(data: string, ty: T): T {
  return JSON.parse<T>(data);
}
@inline
function deserializeBox<T>(srcStart: usize, srcEnd: usize, dst: usize, ty: T): T {
  return JSON.__deserialize<T>(srcStart, srcEnd, dst);
}
@inline
export function toRaw(data: string): JSON.Raw {
  return new JSON.Raw(data);
}
@inline
export function fromRaw(data: JSON.Raw): string {
  return data.data;
}
@inline
export function toBox<T>(data: T): JSON.Box<T> {
  return new JSON.Box<T>(data);
}

Link: JSON.__try_parse<Vec3>("lol")
~lib/json-as/assembly/index 6
assembly/types/error 0
assembly/foo 1
Try Block/Loop: {
  __ExceptionState.Failed = false;
  JSON.__try_parse<Vec3>("lol");
  if (!__ExceptionState.Failed) {
    console.log("This should not execute");
  }
}
Import: import {
  __Exception
} from "./types/exception" in assembly/test.ts
Catch Block: if (__ExceptionState.Failed) {
  let e = new __Exception(__ExceptionState.Type);
  console.log("Got an error: " + e.toString());
  try {
    foo();
  } catch (e) {
    console.log("Got another error: " + e.toString());
  }
  __ExceptionState.Failed = false;
  }
Finally Block: {
  console.log("Gracefully shutting down...");
  process.exit(0);
}
Found try: try {
  foo();
} catch (e) {
  console.log("Got another error: " + e.toString());
}
~lib/json-as/assembly/index 6
assembly/types/error 0
assembly/foo 1
from: /home/port/Code/AssemblyScript/as-try/assembly/test.ts
to: /home/port/Code/AssemblyScript/as-try/assembly/foo.ts
base: /home/port/Code/AssemblyScript/as-try
pkg: /home/port/Code/AssemblyScript/as-try/node_modules
rel path: ./foo
Set Fn __try_foo
Fn (Throw): export function __try_foo(): void {
  throw new Error("Throw from catch");
}
Return Type: void derived from __try_foo
Return: return
Breaker (Throw): return
Release Fn __try_foo
export function foo(): void {
  throw new Error("Throw from catch");
}
export function __try_foo(): void {
  __ErrorState.error("Throw from catch");
  return;
}

Link: __try_foo()
Try Block/Loop: {
  __ExceptionState.Failed = false;
  __try_foo();
  if (!__ExceptionState.Failed) {}
}
Catch Block: if (__ExceptionState.Failed) {
  let e = new __Exception(__ExceptionState.Type);
  console.log("Got another error: " + e.toString());
  __ExceptionState.Failed = false;
}
import {
  __try_foo
} from "./foo";
import {
  __Exception
} from "./types/exception";
import {
  __ExceptionState
} from "./types/exception";
import {
  JSON
} from "json-as";
import {
  __ErrorState
} from "./types/error";
import {
  foo
} from "./foo";
@json
class Vec3 {
  public a: string = "";
}
{
  __ExceptionState.Failed = false;
  JSON.__try_parse<Vec3>("lol");
  if (!__ExceptionState.Failed) {
    console.log("This should not execute");
  }
}
if (__ExceptionState.Failed) {
  let e = new __Exception(__ExceptionState.Type);
  console.log("Got an error: " + e.toString());
  {
    __ExceptionState.Failed = false;
    __try_foo();
    if (!__ExceptionState.Failed) {}
  }
  if (__ExceptionState.Failed) {
    let e = new __Exception(__ExceptionState.Type);
    console.log("Got another error: " + e.toString());
    __ExceptionState.Failed = false;
  }
  __ExceptionState.Failed = false;
}
{
  console.log("Gracefully shutting down...");
  process.exit(0);
}

